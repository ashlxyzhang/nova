#version 450

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(set = 1, binding = 0, rgba8) uniform image2D out_image;
layout(set = 1, binding = 1, r32ui) uniform uimage2D positive_texture;
layout(set = 1, binding = 2, r32ui) uniform uimage2D negative_texture;

layout(set = 2, binding = 0) uniform Uniforms {
    vec4 posCol;
    vec4 neutCol;
    vec4 negCol;
    vec4 floatFlags; // x: color option, y: scale, z: activation function
    vec4 flags;      // x: posOnly?, y: morlet (unused)
} ubo;


void main() {
    uvec3 gid = gl_GlobalInvocationID;
    uint positive_events = imageLoad(positive_texture, ivec2(gid.xy))[0];
    uint negative_events = imageLoad(negative_texture, ivec2(gid.xy))[0];

    

    float scale = ubo.floatFlags.y;
    vec4 color;

    vec4 colorNeg = ubo.negCol;
    vec4 colorPos = ubo.posCol;
    vec4 colorNeut = ubo.neutCol;
    vec4 colorMix = mix(colorNeg, colorPos, 0.5);
    float eventDiff = float(positive_events) - float(negative_events);

    if(ubo.floatFlags.x < 0.9 || ubo.floatFlags.x > 1.1) {
        colorNeut = colorMix;
    }
    if(ubo.floatFlags.z > 0.9) {
        float colorScale = 1/(1+exp(-scale*(eventDiff)));
        float negScale = 1.0 - colorScale;
        if (colorScale > 0.5) {
            color = mix(colorNeut, colorPos, (colorScale - 0.5) * 2.0);
        } else {
            color = mix(colorNeut, colorNeg, (negScale - 0.5) * 2.0);
        }
    } else {
        float colorScale = max(0.0, min(1.0, 0.5 + 0.25 * scale * eventDiff));
        float negScale = 1.0 - colorScale;
        if (colorScale > 0.5) {
            color = mix(colorNeut, colorPos, (colorScale - 0.5) * 2.0);
        } else {
            color = mix(colorNeut, colorNeg, (negScale - 0.5) * 2.0);
        }
    }
    vec4 newColor = color;

    imageStore(out_image, ivec2(gid.xy), newColor);
}
